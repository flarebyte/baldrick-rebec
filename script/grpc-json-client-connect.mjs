// Connect-Node based gRPC client (JSON-friendly wrapper)
//
// This implementation follows Connect-Node conventions and expects a generated
// ServiceType from @connectrpc/connect. It wraps the Connect client to:
// - accept plain JSON objects for requests (validated/coerced by MessageType.fromJson)
// - return plain JSON objects for responses (via MessageType.toJson)
// - keep a minimal public API: create client bound to base URL, call RPCs
//
// Usage (example, not wired in tests yet):
//   import {createConnectGrpcJsonClient} from './grpc-json-client-connect.mjs';
//   import { PromptService } from '../gen/prompt/v1/prompt_connect.js'; // generated by protoc-gen-connect-es
//   const client = createConnectGrpcJsonClient({ baseUrl: 'http://127.0.0.1:53051', service: PromptService });
//   const out = await client.Run({ tool_name: 'ollama-gemma', input: 'Hello' });
//
// Notes:
// - This transport targets the gRPC protocol by default. Your Go server currently
//   uses gRPC with a JSON codec (content-type application/grpc+json). Connect's
//   gRPC transport typically uses binary Protobuf over application/grpc. If you
//   want to interoperate with application/grpc+json, consider switching the
//   server to the Connect protocol (application/connect+json) or generate clients
//   and use Protobuf binary over gRPC. This file demonstrates a clean Connect
//   wrapper; wiring depends on server protocol alignment.

import { createPromiseClient } from '@connectrpc/connect';
import { createConnectTransport } from '@connectrpc/connect-node';

// Optional: interceptor to add/override headers (e.g., force JSON content-type for experiments)
function headerInterceptor(extraHeaders = {}) {
  return (next) => async (req) => {
    // Merge headers (case-insensitive keys by convention)
    for (const [k, v] of Object.entries(extraHeaders)) {
      req.header.set(k, String(v));
    }
    return await next(req);
  };
}

// Creates a Connect client and exposes RPCs that accept/return plain JSON.
export function createConnectGrpcJsonClient({ baseUrl, service, headers = {} }) {
  if (!baseUrl || !service) {
    throw new Error('baseUrl and service are required');
  }
  const transport = createConnectTransport({ baseUrl, interceptors: Object.keys(headers).length ? [headerInterceptor(headers)] : undefined });
  const c = createPromiseClient(service, transport);

  // Build a thin JSON wrapper around the Connect client using runtime metadata.
  const api = {};
  for (const m of service.methods) {
    const name = m.localName;
    const In = m.I; // @bufbuild/protobuf message type
    const Out = m.O; // @bufbuild/protobuf message type
    api[name] = async (jsonReq = {}, options = {}) => {
      // Validate/coerce input JSON into a Message via fromJson
      let msgIn;
      try {
        msgIn = In.fromJson(jsonReq, { ignoreUnknownFields: false });
      } catch (e) {
        const detail = e?.message || String(e);
        throw new Error(`request validation failed: ${detail}`);
      }
      // Call the RPC
      let res;
      try {
        res = await c[name](msgIn, options);
      } catch (e) {
        // Surface Connect/gRPC errors deterministically
        const code = e?.code !== undefined ? ` code=${e.code}` : '';
        const msg = e?.message || String(e);
        throw new Error(`rpc ${name} failed:${code} ${msg}`);
      }
      // Convert Message to plain JSON
      return Out.toJson(res, { emitDefaultValues: false });
    };
  }
  return api;
}
